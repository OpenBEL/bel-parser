#include <stdio.h>
#include <string.h>
#include "../src/libbel.h"
#include "../src/bel-parser.h"

// Test constraint
#define LINE_CHAR_LEN 1024 * 32 // 32 kilobytes

#test statement_part_completion
    char empty                       [LINE_CHAR_LEN] = "";
    char partial_function            [LINE_CHAR_LEN] = "a";
    char partial_string_function     [LINE_CHAR_LEN] = "\"a\"";
    char incomplete_namespace_value  [LINE_CHAR_LEN] = "a:";
    char namespace_value             [LINE_CHAR_LEN] = "a:b";
    char multiple_namespace_value    [LINE_CHAR_LEN] = "a:b, c:d";

    ck_assert_str_eq(
        bel_ast_as_string(bel_parse_term(empty)),
        "NULL[0] (null) (null) "
    );
    ck_assert_str_eq(
        bel_ast_as_string(bel_parse_term(partial_function)),
        "ARG[1] NV[1] pfx((null)) val(a) ARG[0] (null) (null) "
    );
    ck_assert_str_eq(
        bel_ast_as_string(bel_parse_term(partial_string_function)),
        "ARG[1] NV[1] pfx((null)) val(\"a\") ARG[0] (null) (null) "
        );
    ck_assert_str_eq(
        bel_ast_as_string(bel_parse_term(incomplete_namespace_value)),
        "ARG[0] NV[0] pfx(a) val((null)) ARG[0] (null) (null) "
    );
    ck_assert_str_eq(
        bel_ast_as_string(bel_parse_term(namespace_value)),
        "ARG[1] NV[1] pfx(a) val(b) ARG[0] (null) (null) "
    );
    ck_assert_str_eq(
        bel_ast_as_string(bel_parse_term(multiple_namespace_value)),
        "ARG[1] NV[1] pfx(a) val(b) ARG[1] NV[1] pfx(c) val(d) ARG[0] (null) (null) "
    );

// vim: ft=c sw=4 ts=4 sts=4 expandtab
